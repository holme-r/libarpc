/*
 * Please do not edit this file.
 * It was generated using rpcgen.
 */

#ifndef _PMAP_PROT_H_RPCGEN
#define	_PMAP_PROT_H_RPCGEN

#include <libarpc/arpc.h>

#ifdef __cplusplus
extern "C" {
#endif

/*
 * Sun RPC is a product of Sun Microsystems, Inc. and is provided for
 * unrestricted use provided that this legend is included on all tape
 * media and as a part of the software program in whole or part.  Users
 * may copy or modify Sun RPC without charge, but are not authorized
 * to license or distribute it to anyone else except as part of a product or
 * program developed by the user.
 *
 * SUN RPC IS PROVIDED AS IS WITH NO WARRANTIES OF ANY KIND INCLUDING THE
 * WARRANTIES OF DESIGN, MERCHANTIBILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE, OR ARISING FROM A COURSE OF DEALING, USAGE OR TRADE PRACTICE.
 *
 * Sun RPC is provided with no support and without any obligation on the
 * part of Sun Microsystems, Inc. to assist in its use, correction,
 * modification or enhancement.
 *
 * SUN MICROSYSTEMS, INC. SHALL HAVE NO LIABILITY WITH RESPECT TO THE
 * INFRINGEMENT OF COPYRIGHTS, TRADE SECRETS OR ANY PATENTS BY SUN RPC
 * OR ANY PART THEREOF.
 *
 * In no event will Sun Microsystems, Inc. be liable for any lost revenue
 * or profits or other special, indirect and consequential damages, even if
 * Sun has been advised of the possibility of such damages.
 *
 * Sun Microsystems, Inc.
 * 2550 Garcia Avenue
 * Mountain View, California  94043
 */
/*
 * Copyright (c) 1984,1989 by Sun Microsystems, Inc.
 */
/* from pmap_prot.x */

/* #pragma ident	"@(#)pmap_prot.x	1.6	94/04/29 SMI" */


/*
 * Protocol for the local binder service, or pmap.
 *
 * Copyright (C) 1984, Sun Microsystems, Inc.
 *
 * The following procedures are supported by the protocol:
 *
 * PMAPPROC_NULL() returns ()
 * 	takes nothing, returns nothing
 *
 * PMAPPROC_SET(struct pmap) returns (bool_t)
 * 	TRUE is success, FALSE is failure.  Registers the tuple
 *	[prog, vers, prot, port].
 *
 * PMAPPROC_UNSET(struct pmap) returns (bool_t)
 *	TRUE is success, FALSE is failure.  Un-registers pair
 *	[prog, vers].  prot and port are ignored.
 *
 * PMAPPROC_GETPORT(struct pmap) returns (long unsigned).
 *	0 is failure.  Otherwise returns the port number where the pair
 *	[prog, vers] is registered.  It may lie!
 *
 * PMAPPROC_DUMP() RETURNS (struct pmaplist_ptr)
 *
 * PMAPPROC_CALLIT(unsigned, unsigned, unsigned, string<>)
 * 	RETURNS (port, string<>);
 * usage: encapsulatedresults = PMAPPROC_CALLIT(prog, vers, proc,
 *						encapsulatedargs);
 * 	Calls the procedure on the local machine.  If it is not registered,
 *	this procedure is quite; ie it does not return error information!!!
 *	This procedure only is supported on rpc/udp and calls via
 *	rpc/udp.  This routine only passes null authentication parameters.
 *	This file has no interface to xdr routines for PMAPPROC_CALLIT.
 *
 * The service supports remote procedure calls on udp/ip or tcp/ip socket 111.
 */

#define	PMAPPORT 111


/*
 * A mapping of (program, version, protocol) to port number
 */

struct ar_pmap {
	u_long pm_prog;
	u_long pm_vers;
	u_long pm_prot;
	u_long pm_port;
};
typedef struct ar_pmap ar_pmap;

/*
 * Supported values for the "prot" field
 */

#define	AR_PMAP_IPPROTO_TCP 6
#define	AR_PMAP_IPPROTO_UDP 17


/*
 * A list of mappings
 *
 * Below are two definitions for the pmaplist structure.  This is done because
 * xdr_pmaplist() is specified to take a struct pmaplist **, rather than a
 * struct pmaplist * that rpcgen would produce.  One version of the pmaplist
 * structure (actually called pm__list) is used with rpcgen, and the other is
 * defined only in the header file for compatibility with the specified
 * interface.
 */

struct ar_pm__list {
	ar_pmap pml_map;
	struct ar_pm__list *pml_next;
};
typedef struct ar_pm__list ar_pm__list;

typedef ar_pm__list *ar_pmaplist_ptr;

typedef struct ar_pm__list ar_pmaplist_t;


#ifdef __cplusplus
extern "C" {
#endif
extern  axdr_ret_t axdr_ar_pmaplist(axdr_state_t *, ar_pmaplist_t **);
#ifdef	__cplusplus
}
#endif


/*
 * Arguments to callit
 */

struct ar_rmtcallargs {
	u_long prog;
	u_long vers;
	u_long proc;
	struct {
		u_int args_len;
		char *args_val;
	} args;
};
typedef struct ar_rmtcallargs ar_rmtcallargs;

/*
 * Client-side only representation of rmtcallargs structure.
 *
 * The routine that XDRs the rmtcallargs structure must deal with the
 * opaque arguments in the "args" structure.  xdr_rmtcall_args() needs to be
 * passed the XDR routine that knows the args' structure.  This routine
 * doesn't need to go over-the-wire (and it wouldn't make sense anyway) since
 * the application being called knows the args structure already.  So we use a
 * different "XDR" structure on the client side, p_rmtcallargs, which includes
 * the args' XDR routine.
 */
struct ar_p_rmtcallargs {
	u_long prog;
	u_long vers;
	u_long proc;
	struct {
		u_int args_len;
		char *args_val;
	} args;
	axdrproc_t	xdr_args;	/* encodes args */
};



/*
 * Results of callit
 */

struct ar_rmtcallres {
	u_long port;
	struct {
		u_int res_len;
		char *res_val;
	} res;
};
typedef struct ar_rmtcallres ar_rmtcallres;

/*
 * Client-side only representation of rmtcallres structure.
 */
struct ar_p_rmtcallres {
	u_long port;
	struct {
		u_int res_len;
		char *res_val;
	} res;
	axdrproc_t	xdr_res;	/* decodes res */
};


#define AR_PMAPVERS_PROTO		((u_long)2)
#define AR_PMAPVERS_ORIG		((u_long)1)


#define	PMAPPROG ((unsigned long)(100000))
#define	PMAPVERS ((unsigned long)(2))
extern  void pmapprog_2_lookup(u_int32_t, ar_svc_handler_fn_t *, 
	axdrproc_t *, axdrproc_t *, int *, int *);
#define	AR_PMAPPROC_NULL ((unsigned long)(0))
extern  ar_stat_t ar_pmapproc_null_2(void *, ar_client_t *);
extern  bool_t ar_pmapproc_null_2_svc(void *, ar_svc_req_t *);
typedef void (*ar_pmapproc_null_2_cb_t)(ar_clnt_call_obj_t cco, void *arg, const arpc_err_t *stat, void *);
ar_stat_t ar_pmapproc_null_2_async( ar_client_t *clnt, ar_pmapproc_null_2_cb_t resfn, void *arg, ar_clnt_call_obj_t *ccop);
#define	AR_PMAPPROC_SET ((unsigned long)(1))
extern  ar_stat_t ar_pmapproc_set_2(ar_pmap , bool_t *, ar_client_t *);
extern  bool_t ar_pmapproc_set_2_svc(ar_pmap , bool_t *, ar_svc_req_t *);
typedef void (*ar_pmapproc_set_2_cb_t)(ar_clnt_call_obj_t cco, void *arg, const arpc_err_t *stat, bool_t *);
ar_stat_t ar_pmapproc_set_2_async(ar_pmap ,  ar_client_t *clnt, ar_pmapproc_set_2_cb_t resfn, void *arg, ar_clnt_call_obj_t *ccop);
#define	AR_PMAPPROC_UNSET ((unsigned long)(2))
extern  ar_stat_t ar_pmapproc_unset_2(ar_pmap , bool_t *, ar_client_t *);
extern  bool_t ar_pmapproc_unset_2_svc(ar_pmap , bool_t *, ar_svc_req_t *);
typedef void (*ar_pmapproc_unset_2_cb_t)(ar_clnt_call_obj_t cco, void *arg, const arpc_err_t *stat, bool_t *);
ar_stat_t ar_pmapproc_unset_2_async(ar_pmap ,  ar_client_t *clnt, ar_pmapproc_unset_2_cb_t resfn, void *arg, ar_clnt_call_obj_t *ccop);
#define	AR_PMAPPROC_GETPORT ((unsigned long)(3))
extern  ar_stat_t ar_pmapproc_getport_2(ar_pmap , u_long *, ar_client_t *);
extern  bool_t ar_pmapproc_getport_2_svc(ar_pmap , u_long *, ar_svc_req_t *);
typedef void (*ar_pmapproc_getport_2_cb_t)(ar_clnt_call_obj_t cco, void *arg, const arpc_err_t *stat, u_long *);
ar_stat_t ar_pmapproc_getport_2_async(ar_pmap ,  ar_client_t *clnt, ar_pmapproc_getport_2_cb_t resfn, void *arg, ar_clnt_call_obj_t *ccop);
#define	AR_PMAPPROC_DUMP ((unsigned long)(4))
extern  ar_stat_t ar_pmapproc_dump_2(ar_pmaplist_ptr *, ar_client_t *);
extern  bool_t ar_pmapproc_dump_2_svc(ar_pmaplist_ptr *, ar_svc_req_t *);
typedef void (*ar_pmapproc_dump_2_cb_t)(ar_clnt_call_obj_t cco, void *arg, const arpc_err_t *stat, ar_pmaplist_ptr *);
ar_stat_t ar_pmapproc_dump_2_async( ar_client_t *clnt, ar_pmapproc_dump_2_cb_t resfn, void *arg, ar_clnt_call_obj_t *ccop);
#define	AR_PMAPPROC_CALLIT ((unsigned long)(5))
extern  ar_stat_t ar_pmapproc_callit_2(ar_rmtcallargs , ar_rmtcallres *, ar_client_t *);
extern  bool_t ar_pmapproc_callit_2_svc(ar_rmtcallargs , ar_rmtcallres *, ar_svc_req_t *);
typedef void (*ar_pmapproc_callit_2_cb_t)(ar_clnt_call_obj_t cco, void *arg, const arpc_err_t *stat, ar_rmtcallres *);
ar_stat_t ar_pmapproc_callit_2_async(ar_rmtcallargs ,  ar_client_t *clnt, ar_pmapproc_callit_2_cb_t resfn, void *arg, ar_clnt_call_obj_t *ccop);

/* the axdr functions */
extern axdr_ret_t axdr_ar_pmap(axdr_state_t *, ar_pmap*);
extern axdr_ret_t axdr_ar_pm__list(axdr_state_t *, ar_pm__list*);
extern axdr_ret_t axdr_ar_pmaplist_ptr(axdr_state_t *, ar_pmaplist_ptr*);
extern axdr_ret_t axdr_ar_rmtcallargs(axdr_state_t *, ar_rmtcallargs*);
extern axdr_ret_t axdr_ar_rmtcallres(axdr_state_t *, ar_rmtcallres*);

#ifdef __cplusplus
}
#endif

#endif /* !_PMAP_PROT_H_RPCGEN */
